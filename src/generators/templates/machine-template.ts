/**
 * XState v5 Machine Template Generator
 *
 * This module provides templates for generating XState v5 machines following
 * the established patterns in the SupaMoto USSD server codebase.
 *
 * @module machine-template
 * @version 1.0.0
 */

import type {
  GeneratedMachineSpec,
  GeneratedStateSpec,
  GeneratedEventSpec,
  GeneratedContextSpec,
  MachineCategory,
} from "../types/generator-types.js";

/**
 * Template configuration for machine generation
 */
export interface TemplateConfig {
  /** Whether to include demo file generation */
  includeDemos: boolean;

  /** Whether to include test file generation */
  includeTests: boolean;

  /** Whether to use strict TypeScript mode */
  strictMode: boolean;

  /** Custom imports to add */
  customImports: string[];

  /** Template style variant */
  variant: "standard" | "minimal" | "comprehensive";
}

/**
 * Default template configuration
 */
export const DEFAULT_TEMPLATE_CONFIG: TemplateConfig = {
  includeDemos: true,
  includeTests: true,
  strictMode: true,
  customImports: [],
  variant: "standard",
};

/**
 * Main machine template generator class
 */
export class MachineTemplateGenerator {
  private config: TemplateConfig;

  constructor(config: Partial<TemplateConfig> = {}) {
    this.config = { ...DEFAULT_TEMPLATE_CONFIG, ...config };
  }

  /**
   * Generate complete XState v5 machine code
   */
  generateMachine(spec: GeneratedMachineSpec): string {
    const parts = [
      this.generateHeader(spec),
      this.generateImports(spec),
      this.generateTypes(spec),
      this.generateMachineDefinition(spec),
      this.generateExports(spec),
    ];

    return parts.join("\n\n");
  }

  /**
   * Generate file header with documentation
   */
  private generateHeader(spec: GeneratedMachineSpec): string {
    const categoryDescription = this.getCategoryDescription(spec.category);

    return `/**
 * ${spec.name} - Generated XState v5 Machine
 *
 * ${spec.description || `Auto-generated ${categoryDescription} machine from Mermaid specification.`}
 * 
 * This file was automatically generated from the USSD menu Mermaid diagram.
 * Do not edit this file directly. Instead, update the source diagram and regenerate.
 *
 * @module ${spec.name}
 * @category ${spec.category}
 * @generated true
 * @version 1.0.0
 */`;
  }

  /**
   * Generate import statements
   */
  private generateImports(spec: GeneratedMachineSpec): string {
    const imports = [
      'import { setup, assign, fromPromise } from "xstate";',
      ...spec.imports,
      ...this.config.customImports,
    ];

    // Add category-specific imports
    if (spec.category === "user-machine") {
      imports.push('import type { UserContext } from "../shared/types.js";');
    }

    if (spec.category === "agent-machine") {
      imports.push('import type { AgentContext } from "../shared/types.js";');
    }

    return imports.filter(Boolean).join("\n");
  }

  /**
   * Generate TypeScript type definitions
   */
  private generateTypes(spec: GeneratedMachineSpec): string {
    const contextType = this.generateContextType(spec.context);
    const eventTypes = this.generateEventTypes(spec.events);

    return `${contextType}\n\n${eventTypes}`;
  }

  /**
   * Generate context interface
   */
  private generateContextType(context: GeneratedContextSpec[]): string {
    if (context.length === 0) {
      return `/**
 * Machine context interface
 */
export interface Context {
  // No context fields defined
}`;
    }

    const fields = context
      .map(field => {
        const optional = field.optional ? "?" : "";
        const comment = field.description
          ? `  /** ${field.description} */\n`
          : "";
        return `${comment}  ${field.name}${optional}: ${field.type};`;
      })
      .join("\n");

    return `/**
 * Machine context interface
 */
export interface Context {
${fields}
}`;
  }

  /**
   * Generate event type definitions
   */
  private generateEventTypes(events: GeneratedEventSpec[]): string {
    if (events.length === 0) {
      return `/**
 * Machine event types
 */
export type Events = 
  | { type: "START" }
  | { type: "BACK" }
  | { type: "MAIN" }
  | { type: "ERROR"; error?: string };`;
    }

    const eventTypes = events
      .map(event => {
        if (event.payload.length === 0) {
          return `  | { type: "${event.type}" }`;
        }

        const payload = event.payload
          .map(field => {
            const optional = field.optional ? "?" : "";
            return `${field.name}${optional}: ${field.type}`;
          })
          .join("; ");

        return `  | { type: "${event.type}"; ${payload} }`;
      })
      .join("\n");

    return `/**
 * Machine event types
 */
export type Events = 
${eventTypes};`;
  }

  /**
   * Generate the main machine definition
   */
  private generateMachineDefinition(spec: GeneratedMachineSpec): string {
    const guards = this.generateGuards(spec.guards);
    const actions = this.generateActions(spec.actions);
    const actors = this.generateActors(spec.actors);
    const states = this.generateStates(spec.states);

    return `/**
 * ${spec.name} XState v5 Machine
 */
export const ${spec.id} = setup({
  types: {
    context: {} as Context,
    events: {} as Events,
  },
  guards: {${guards}
  },
  actions: {${actions}
  },
  actors: {${actors}
  },
}).createMachine({
  id: "${spec.id}",
  initial: "${spec.initialState}",
  context: ({ input }) => ({
    ${this.generateDefaultContext(spec.context)}
    ...input,
  }),
  states: {${states}
  },
});`;
  }

  /**
   * Generate guards object
   */
  private generateGuards(guards: string[]): string {
    if (guards.length === 0) {
      return `
    // No guards defined`;
    }

    return guards
      .map(
        guard => `
    ${guard}: ({ context, event }) => {
      // TODO: Implement ${guard} guard logic
      return true;
    },`
      )
      .join("");
  }

  /**
   * Generate actions object
   */
  private generateActions(actions: string[]): string {
    if (actions.length === 0) {
      return `
    // No actions defined`;
    }

    return actions
      .map(
        action => `
    ${action}: assign(({ context, event }) => {
      // TODO: Implement ${action} action logic
      return {};
    }),`
      )
      .join("");
  }

  /**
   * Generate actors object
   */
  private generateActors(actors: string[]): string {
    if (actors.length === 0) {
      return `
    // No actors defined`;
    }

    return actors
      .map(
        actor => `
    ${actor}: fromPromise(async ({ input }) => {
      // TODO: Implement ${actor} actor logic
      return input;
    }),`
      )
      .join("");
  }

  /**
   * Generate default context values
   */
  private generateDefaultContext(context: GeneratedContextSpec[]): string {
    if (context.length === 0) {
      return "// No default context";
    }

    return context
      .map(field => {
        return `    ${field.name}: ${field.defaultValue},`;
      })
      .join("\n");
  }

  /**
   * Generate states configuration
   */
  private generateStates(states: GeneratedStateSpec[]): string {
    return states
      .map(state => {
        const entry =
          state.entry && state.entry.length > 0
            ? `\n      entry: [${state.entry.map(a => `"${a}"`).join(", ")}],`
            : "";

        const exit =
          state.exit && state.exit.length > 0
            ? `\n      exit: [${state.exit.map(a => `"${a}"`).join(", ")}],`
            : "";

        const transitions = this.generateTransitions(state.transitions);
        const nestedStates =
          state.states && state.states.length > 0
            ? `\n      states: {${this.generateStates(state.states)}
      },`
            : "";

        const stateType =
          state.type === "final" ? '\n      type: "final",' : "";

        return `
    ${state.name}: {${stateType}${entry}${exit}${transitions}${nestedStates}
    },`;
      })
      .join("");
  }

  /**
   * Generate transitions for a state
   */
  private generateTransitions(
    transitions: GeneratedStateSpec["transitions"]
  ): string {
    if (transitions.length === 0) {
      return "";
    }

    const transitionGroups = new Map<string, typeof transitions>();

    // Group transitions by event
    transitions.forEach(transition => {
      if (!transitionGroups.has(transition.event)) {
        transitionGroups.set(transition.event, []);
      }
      transitionGroups.get(transition.event)!.push(transition);
    });

    const transitionEntries = Array.from(transitionGroups.entries())
      .map(([event, eventTransitions]) => {
        if (eventTransitions.length === 1) {
          const t = eventTransitions[0];
          const target = t.target ? ` target: "${t.target}",` : "";
          const guard = t.guard ? ` guard: "${t.guard}",` : "";
          const actions =
            t.actions && t.actions.length > 0
              ? ` actions: [${t.actions.map(a => `"${a}"`).join(", ")}],`
              : "";

          return `        ${event}: {${target}${guard}${actions} },`;
        } else {
          // Multiple transitions for same event
          const multiTransitions = eventTransitions
            .map(t => {
              const target = t.target ? ` target: "${t.target}",` : "";
              const guard = t.guard ? ` guard: "${t.guard}",` : "";
              const actions =
                t.actions && t.actions.length > 0
                  ? ` actions: [${t.actions.map(a => `"${a}"`).join(", ")}],`
                  : "";

              return `          {${target}${guard}${actions} }`;
            })
            .join(",\n");

          return `        ${event}: [\n${multiTransitions}\n        ],`;
        }
      })
      .join("\n");

    return `\n      on: {
${transitionEntries}
      },`;
  }

  /**
   * Generate export statements
   */
  private generateExports(spec: GeneratedMachineSpec): string {
    return `// Export types for external use
export type { Context, Events };

// Export machine for use in parent machines
export default ${spec.id};`;
  }

  /**
   * Get description for machine category
   */
  private getCategoryDescription(category: MachineCategory): string {
    const descriptions = {
      "info-machine": "information and read-only",
      "user-machine": "authenticated user service",
      "agent-machine": "agent-specific workflow",
      "account-machine": "account management",
      "core-machine": "core system routing",
    };

    return descriptions[category] || "general purpose";
  }
}

/**
 * Convenience function to generate machine code
 */
export function generateMachineCode(
  spec: GeneratedMachineSpec,
  config?: Partial<TemplateConfig>
): string {
  const generator = new MachineTemplateGenerator(config);
  return generator.generateMachine(spec);
}
